"""
Tests for agentic_kg.agents.checkpoints.

Generated by test-generator agent.
"""

import pytest

from agentic_kg.agents.checkpoints import CheckpointManager
from agentic_kg.agents.schemas import CheckpointDecision, CheckpointType
from agentic_kg.agents.state import create_initial_state


class TestCheckpointManager:
    """Tests for CheckpointManager.apply_decision."""

    @pytest.fixture
    def state_with_ranked(self, state_with_ranked_problems):
        return state_with_ranked_problems

    # -------------------------------------------------------------------------
    # SELECT_PROBLEM
    # -------------------------------------------------------------------------

    def test_select_problem_approve_picks_top(self, state_with_ranked):
        """Approve selects the top-ranked problem."""
        result = CheckpointManager.apply_decision(
            state_with_ranked,
            CheckpointType.SELECT_PROBLEM,
            CheckpointDecision.APPROVE,
        )
        assert result["selected_problem_id"] == "prob-1"

    def test_select_problem_reject_clears_selection(self, state_with_ranked):
        """Reject clears selected problem."""
        result = CheckpointManager.apply_decision(
            state_with_ranked,
            CheckpointType.SELECT_PROBLEM,
            CheckpointDecision.REJECT,
        )
        assert result["selected_problem_id"] is None

    def test_select_problem_edit_with_custom_id(self, state_with_ranked):
        """Edit allows selecting a specific problem."""
        result = CheckpointManager.apply_decision(
            state_with_ranked,
            CheckpointType.SELECT_PROBLEM,
            CheckpointDecision.EDIT,
            edited_data={"problem_id": "prob-99", "statement": "Custom problem"},
        )
        assert result["selected_problem_id"] == "prob-99"
        assert result["selected_problem_statement"] == "Custom problem"

    def test_select_problem_approve_empty_list(self):
        """Approve with empty ranked list sets None."""
        state = create_initial_state()
        state = {**state, "ranked_problems": []}
        result = CheckpointManager.apply_decision(
            state,
            CheckpointType.SELECT_PROBLEM,
            CheckpointDecision.APPROVE,
        )
        assert result["selected_problem_id"] is None

    # -------------------------------------------------------------------------
    # APPROVE_PROPOSAL
    # -------------------------------------------------------------------------

    def test_approve_proposal(self, state_with_proposal):
        """Approve sets proposal_approved to True."""
        state = {**state_with_proposal, "proposal_approved": False}
        result = CheckpointManager.apply_decision(
            state,
            CheckpointType.APPROVE_PROPOSAL,
            CheckpointDecision.APPROVE,
        )
        assert result["proposal_approved"] is True

    def test_reject_proposal(self, state_with_proposal):
        """Reject sets proposal_approved to False."""
        result = CheckpointManager.apply_decision(
            state_with_proposal,
            CheckpointType.APPROVE_PROPOSAL,
            CheckpointDecision.REJECT,
        )
        assert result["proposal_approved"] is False

    def test_edit_proposal_merges_data(self, state_with_proposal):
        """Edit merges edited_data into proposal."""
        result = CheckpointManager.apply_decision(
            state_with_proposal,
            CheckpointType.APPROVE_PROPOSAL,
            CheckpointDecision.EDIT,
            edited_data={"title": "Revised Title"},
        )
        assert result["proposal_approved"] is True
        assert result["proposal"]["title"] == "Revised Title"

    # -------------------------------------------------------------------------
    # REVIEW_EVALUATION
    # -------------------------------------------------------------------------

    def test_approve_evaluation(self, state_with_evaluation):
        """Approve sets evaluation_approved to True."""
        state = {**state_with_evaluation, "evaluation_approved": False}
        result = CheckpointManager.apply_decision(
            state,
            CheckpointType.REVIEW_EVALUATION,
            CheckpointDecision.APPROVE,
        )
        assert result["evaluation_approved"] is True

    def test_reject_evaluation(self, state_with_evaluation):
        """Reject sets evaluation_approved to False."""
        result = CheckpointManager.apply_decision(
            state_with_evaluation,
            CheckpointType.REVIEW_EVALUATION,
            CheckpointDecision.REJECT,
        )
        assert result["evaluation_approved"] is False

    # -------------------------------------------------------------------------
    # Checkpoint recording
    # -------------------------------------------------------------------------

    def test_checkpoint_recorded(self, state_with_ranked):
        """Decision is recorded in human_checkpoints."""
        result = CheckpointManager.apply_decision(
            state_with_ranked,
            CheckpointType.SELECT_PROBLEM,
            CheckpointDecision.APPROVE,
            feedback="LGTM",
        )
        assert len(result["human_checkpoints"]) == 1
        cp = result["human_checkpoints"][0]
        assert cp["checkpoint_type"] == "select_problem"
        assert cp["decision"] == "approve"
        assert cp["feedback"] == "LGTM"
