"""
Tests for agentic_kg.agents.sandbox.

Generated by test-generator agent.
"""

import json
from unittest.mock import MagicMock, patch

import pytest

from agentic_kg.agents.config import SandboxConfig, reset_agent_config
from agentic_kg.agents.sandbox import DockerSandbox, SandboxResult


# =============================================================================
# SandboxResult
# =============================================================================


class TestSandboxResult:
    """Tests for SandboxResult dataclass."""

    def test_create(self):
        """Create with basic fields."""
        sr = SandboxResult(success=True, stdout="output", stderr="", exit_code=0)
        assert sr.success is True
        assert sr.timed_out is False
        assert sr.metrics is None

    def test_parse_metrics_from_json_stdout(self):
        """parse_metrics extracts JSON from last line of stdout."""
        sr = SandboxResult(
            success=True,
            stdout='Some output\n{"metrics": {"accuracy": 0.95}}',
            stderr="",
            exit_code=0,
        )
        metrics = sr.parse_metrics()
        assert metrics["metrics"]["accuracy"] == 0.95

    def test_parse_metrics_returns_empty_on_no_json(self):
        """parse_metrics returns empty dict when no JSON found."""
        sr = SandboxResult(
            success=True,
            stdout="Just plain text output",
            stderr="",
            exit_code=0,
        )
        metrics = sr.parse_metrics()
        assert metrics == {}

    def test_parse_metrics_cached(self):
        """parse_metrics returns cached result on second call."""
        sr = SandboxResult(
            success=True,
            stdout='{"metrics": {"loss": 0.1}}',
            stderr="",
            exit_code=0,
        )
        first = sr.parse_metrics()
        second = sr.parse_metrics()
        assert first is second

    def test_parse_metrics_with_preexisting(self):
        """parse_metrics returns preexisting metrics if set."""
        sr = SandboxResult(
            success=True,
            stdout="",
            stderr="",
            exit_code=0,
            metrics={"custom": True},
        )
        assert sr.parse_metrics() == {"custom": True}

    def test_parse_metrics_invalid_json_skipped(self):
        """Invalid JSON lines are skipped."""
        sr = SandboxResult(
            success=True,
            stdout='{not valid json\n{"valid": true}',
            stderr="",
            exit_code=0,
        )
        metrics = sr.parse_metrics()
        assert metrics == {"valid": True}

    def test_parse_metrics_empty_stdout(self):
        """Empty stdout returns empty dict."""
        sr = SandboxResult(success=True, stdout="", stderr="", exit_code=0)
        assert sr.parse_metrics() == {}


# =============================================================================
# DockerSandbox
# =============================================================================


class TestDockerSandbox:
    """Tests for DockerSandbox with mocked Docker client."""

    @pytest.fixture(autouse=True)
    def reset_config(self):
        reset_agent_config()
        yield
        reset_agent_config()

    def test_init_default_config(self):
        """Uses default config when none provided."""
        sandbox = DockerSandbox()
        assert sandbox.config.image == "python:3.12-slim"

    def test_init_custom_config(self):
        """Uses custom config when provided."""
        config = SandboxConfig(image="python:3.11", timeout_seconds=60)
        sandbox = DockerSandbox(config=config)
        assert sandbox.config.image == "python:3.11"
        assert sandbox.config.timeout_seconds == 60

    def test_get_client_raises_on_import_error(self):
        """Raises RuntimeError when docker package not available."""
        sandbox = DockerSandbox()
        with patch.dict("sys.modules", {"docker": None}):
            with patch("builtins.__import__", side_effect=ImportError("no docker")):
                with pytest.raises(RuntimeError, match="docker package required"):
                    sandbox._get_client()

    @patch("agentic_kg.agents.sandbox.DockerSandbox._get_client")
    def test_execute_success(self, mock_get_client):
        """Successful execution returns correct SandboxResult."""
        mock_client = MagicMock()
        mock_get_client.return_value = mock_client

        mock_container = MagicMock()
        mock_container.wait.return_value = {"StatusCode": 0}
        mock_container.logs.side_effect = [
            b'{"metrics": {"acc": 0.9}}',  # stdout
            b"",  # stderr
        ]
        mock_client.containers.run.return_value = mock_container

        sandbox = DockerSandbox()
        result = sandbox.execute("print('hello')")

        assert result.success is True
        assert result.exit_code == 0
        mock_container.remove.assert_called_once_with(force=True)

    @patch("agentic_kg.agents.sandbox.DockerSandbox._get_client")
    def test_execute_failure(self, mock_get_client):
        """Failed execution returns success=False."""
        mock_client = MagicMock()
        mock_get_client.return_value = mock_client

        mock_container = MagicMock()
        mock_container.wait.return_value = {"StatusCode": 1}
        mock_container.logs.side_effect = [
            b"",  # stdout
            b"Traceback: error",  # stderr
        ]
        mock_client.containers.run.return_value = mock_container

        sandbox = DockerSandbox()
        result = sandbox.execute("bad code")

        assert result.success is False
        assert result.exit_code == 1

    @patch("agentic_kg.agents.sandbox.DockerSandbox._get_client")
    def test_execute_timeout(self, mock_get_client):
        """Timeout sets timed_out flag."""
        mock_client = MagicMock()
        mock_get_client.return_value = mock_client

        mock_container = MagicMock()
        mock_container.wait.side_effect = Exception("Connection timed out")
        mock_container.remove.return_value = None
        mock_client.containers.run.return_value = mock_container

        sandbox = DockerSandbox()
        result = sandbox.execute("while True: pass")

        assert result.success is False
        assert result.timed_out is True

    @patch("agentic_kg.agents.sandbox.DockerSandbox._get_client")
    def test_execute_with_extra_pip_packages(self, mock_get_client):
        """Extra pip packages are included in the command."""
        mock_client = MagicMock()
        mock_get_client.return_value = mock_client

        mock_container = MagicMock()
        mock_container.wait.return_value = {"StatusCode": 0}
        mock_container.logs.side_effect = [b"ok", b""]
        mock_client.containers.run.return_value = mock_container

        sandbox = DockerSandbox()
        sandbox.execute("print(1)", pip_packages=["torch"])

        call_kwargs = mock_client.containers.run.call_args
        command = call_kwargs.kwargs.get("command") or call_kwargs[1].get("command", "")
        assert "torch" in command
