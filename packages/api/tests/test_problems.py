"""
Tests for agentic_kg_api.routers.problems -- Problem CRUD endpoints.

Generated by test-generator agent.
"""

import pytest
from unittest.mock import MagicMock

from agentic_kg.knowledge_graph.repository import NotFoundError

from tests.conftest import make_problem


# =============================================================================
# GET /api/problems -- List Problems
# =============================================================================


class TestListProblems:
    """Tests for GET /api/problems."""

    def test_list_problems_returns_empty_list(self, client, mock_repo):
        """Returns empty list when no problems exist."""
        mock_repo.list_problems.return_value = []
        response = client.get("/api/problems")
        assert response.status_code == 200
        data = response.json()
        assert data["problems"] == []
        assert data["total"] == 0
        assert data["limit"] == 50
        assert data["offset"] == 0

    def test_list_problems_returns_problems(self, client, mock_repo):
        """Returns list of problem summaries."""
        mock_repo.list_problems.return_value = [
            make_problem(id="p1", statement="Problem 1"),
            make_problem(id="p2", statement="Problem 2"),
        ]
        response = client.get("/api/problems")
        assert response.status_code == 200
        data = response.json()
        assert len(data["problems"]) == 2
        assert data["problems"][0]["id"] == "p1"
        assert data["problems"][1]["id"] == "p2"
        assert data["total"] == 2

    def test_list_problems_with_status_filter(self, client, mock_repo):
        """Filters problems by status."""
        mock_repo.list_problems.return_value = []
        response = client.get("/api/problems?status=open")
        assert response.status_code == 200
        # Verify status was passed to repo
        call_kwargs = mock_repo.list_problems.call_args[1]
        assert call_kwargs["status"] is not None

    def test_list_problems_invalid_status_returns_400(self, client, mock_repo):
        """Invalid status value returns 400."""
        response = client.get("/api/problems?status=invalid_status_xyz")
        assert response.status_code == 400
        assert "Invalid status" in response.json()["detail"]

    def test_list_problems_with_domain_filter(self, client, mock_repo):
        """Filters problems by domain."""
        mock_repo.list_problems.return_value = []
        response = client.get("/api/problems?domain=NLP")
        assert response.status_code == 200
        call_kwargs = mock_repo.list_problems.call_args[1]
        assert call_kwargs["domain"] == "NLP"

    def test_list_problems_with_pagination(self, client, mock_repo):
        """Supports limit and offset pagination."""
        mock_repo.list_problems.return_value = []
        response = client.get("/api/problems?limit=10&offset=20")
        assert response.status_code == 200
        data = response.json()
        assert data["limit"] == 10
        assert data["offset"] == 20

    @pytest.mark.parametrize("limit", [0, -1, 501])
    def test_list_problems_invalid_limit(self, client, mock_repo, limit):
        """Rejects invalid limit values."""
        response = client.get(f"/api/problems?limit={limit}")
        assert response.status_code == 422

    def test_list_problems_negative_offset(self, client, mock_repo):
        """Rejects negative offset."""
        response = client.get("/api/problems?offset=-1")
        assert response.status_code == 422

    def test_list_problems_includes_confidence(self, client, mock_repo):
        """Includes confidence from extraction metadata when present."""
        meta = MagicMock()
        meta.confidence_score = 0.85
        problem = make_problem(extraction_metadata=meta)
        mock_repo.list_problems.return_value = [problem]
        response = client.get("/api/problems")
        data = response.json()
        assert data["problems"][0]["confidence"] == 0.85


# =============================================================================
# GET /api/problems/{problem_id} -- Get Problem Detail
# =============================================================================


class TestGetProblem:
    """Tests for GET /api/problems/{problem_id}."""

    def test_get_existing_problem(self, client, mock_repo):
        """Returns full problem detail for existing problem."""
        problem = make_problem(id="p1", statement="Test problem")
        mock_repo.get_problem.return_value = problem
        response = client.get("/api/problems/p1")
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == "p1"
        assert data["statement"] == "Test problem"

    def test_get_nonexistent_problem_returns_404(self, client, mock_repo):
        """Returns 404 for nonexistent problem."""
        mock_repo.get_problem.side_effect = NotFoundError("not found")
        response = client.get("/api/problems/nonexistent")
        assert response.status_code == 404
        assert "Problem not found" in response.json()["detail"]

    def test_get_problem_includes_evidence(self, client, mock_repo):
        """Returns evidence data when present."""
        evidence = MagicMock()
        evidence.source_doi = "10.1234/test"
        evidence.source_title = "Test Paper"
        evidence.section = "Introduction"
        evidence.quoted_text = "This is a quote."
        problem = make_problem(evidence=evidence)
        mock_repo.get_problem.return_value = problem
        response = client.get("/api/problems/p1")
        data = response.json()
        assert data["evidence"]["source_doi"] == "10.1234/test"

    def test_get_problem_includes_extraction_metadata(self, client, mock_repo):
        """Returns extraction metadata when present."""
        meta = MagicMock()
        meta.extraction_model = "gpt-4"
        meta.confidence_score = 0.9
        meta.extractor_version = "1.0"
        meta.human_reviewed = False
        problem = make_problem(extraction_metadata=meta)
        mock_repo.get_problem.return_value = problem
        response = client.get("/api/problems/p1")
        data = response.json()
        assert data["extraction_metadata"]["extraction_model"] == "gpt-4"
        assert data["extraction_metadata"]["confidence_score"] == 0.9

    def test_get_problem_includes_assumptions(self, client, mock_repo):
        """Returns assumptions list."""
        assumption = MagicMock()
        assumption.text = "Data is IID"
        assumption.implicit = False
        assumption.confidence = 0.8
        problem = make_problem(assumptions=[assumption])
        mock_repo.get_problem.return_value = problem
        response = client.get("/api/problems/p1")
        data = response.json()
        assert len(data["assumptions"]) == 1
        assert data["assumptions"][0]["text"] == "Data is IID"


# =============================================================================
# PUT /api/problems/{problem_id} -- Update Problem
# =============================================================================


class TestUpdateProblem:
    """Tests for PUT /api/problems/{problem_id}."""

    def test_update_status(self, client, mock_repo):
        """Updates problem status."""
        problem = make_problem(id="p1")
        mock_repo.get_problem.return_value = problem
        mock_repo.update_problem.return_value = problem
        response = client.put("/api/problems/p1", json={"status": "open"})
        assert response.status_code == 200

    def test_update_domain(self, client, mock_repo):
        """Updates problem domain."""
        problem = make_problem(id="p1")
        mock_repo.get_problem.return_value = problem
        mock_repo.update_problem.return_value = problem
        response = client.put("/api/problems/p1", json={"domain": "CV"})
        assert response.status_code == 200

    def test_update_statement(self, client, mock_repo):
        """Updates problem statement."""
        problem = make_problem(id="p1")
        mock_repo.get_problem.return_value = problem
        mock_repo.update_problem.return_value = problem
        response = client.put("/api/problems/p1", json={"statement": "Updated"})
        assert response.status_code == 200

    def test_update_nonexistent_problem_returns_404(self, client, mock_repo):
        """Returns 404 when updating nonexistent problem."""
        mock_repo.get_problem.side_effect = NotFoundError("not found")
        response = client.put("/api/problems/nonexistent", json={"status": "open"})
        assert response.status_code == 404

    def test_update_invalid_status_returns_400(self, client, mock_repo):
        """Returns 400 for invalid status value."""
        problem = make_problem(id="p1")
        mock_repo.get_problem.return_value = problem
        response = client.put("/api/problems/p1", json={"status": "bogus_status"})
        assert response.status_code == 400
        assert "Invalid status" in response.json()["detail"]


# =============================================================================
# DELETE /api/problems/{problem_id} -- Delete Problem
# =============================================================================


class TestDeleteProblem:
    """Tests for DELETE /api/problems/{problem_id}."""

    def test_delete_existing_problem(self, client, mock_repo):
        """Soft-deletes an existing problem."""
        response = client.delete("/api/problems/p1")
        assert response.status_code == 200
        data = response.json()
        assert data["deleted"] is True
        assert data["id"] == "p1"
        mock_repo.delete_problem.assert_called_once_with("p1", soft=True)

    def test_delete_nonexistent_problem_returns_404(self, client, mock_repo):
        """Returns 404 when deleting nonexistent problem."""
        mock_repo.delete_problem.side_effect = NotFoundError("not found")
        response = client.delete("/api/problems/nonexistent")
        assert response.status_code == 404
